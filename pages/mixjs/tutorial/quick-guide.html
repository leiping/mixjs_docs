<h1>Mixjs入门手册 <strong>quick guide</strong></h1>
<p>MIX 是Mobile In X的缩写，它寓意着移动前端技术的一种集合。我们推出MIX框架（平台），是希望为移动前端提供便捷，同时不失为强大的开发框架（平台）。它有形形色色的最佳实践组成，包括从许多成熟的前端架构中汲取精华。

</p>
<h2>前奏</h2>
<p>MIX需要依赖一些开发环境和工具，为了能顺利的使用MIX，请参照一下几点做好准备工作。

</p>
<h3>编译环境</h3>
<p><strong>NodeJS</strong>

</p>
<p>首先是大名鼎鼎的NodeJS，你需要下载并安装最新版本的<a href="http://nodejs.org/download/">NodeJS</a>。并且配置好系统环境变量，以便能快捷访问Node命令。

</p>
<pre><code>&gt; node -v
&gt; v0.8.14</code></pre>
<p>当在命令行输入node -v，并输出当前Node版本时，就代表已经安装成功。

</p>
<h3>安装NPM模块</h3>
<p><strong>spm</strong>

</p>
<p>MIX代码的编译和部署依赖于<a href="https://github.com/seajs/spm">SPM</a>（@玉伯），它是类似于Node自带的NPM的模块管理工具。

</p>
<p>首先需要通过NPM来安装SPM，进入NodeJS的安装目录，执行以下命令：

</p>
<pre><code>$ npm install spm -g</code></pre>
<p>安装成功后，会生成一个<code>.spm</code>目录（在当前登录系统的用户名目录下，比如<code>c:\user\zhuxun.jb</code>或<code>/Users/terry</code>）。其中sources目录用来存放通过spm build/install命令创建或安装的包。congfig.json文件用来配置spm的全局属性。

</p>
<p><strong>spmbatch</strong>

</p>
<p>此模块支持在当前目录下深度遍历执行spm的命令，方便批量编译和上传。

</p>
<pre><code>$ npm install spmbatch -g</code></pre>
<p><strong>fmonitor</strong>

</p>
<p>此模块支持在文件修改的同时，运行给定的一些命令。

</p>
<pre><code>$ npm install fmonitor -g</code></pre>
<p><strong>projinit</strong>

</p>
<p>此模块用于生成一些默认的工程或应用。

</p>
<pre><code>$ npm install projinit -g</code></pre>
<h3>服务器</h3>
<p><strong>Nginx/Apache/node-express</strong>

</p>
<p>为了本地调试，还需要能配置一个WEB容器。<a href="http://nginx.org/">Nginx</a>、<a href="http://www.apache.org/">Apache</a>以及Node的<a href="http://expressjs.com/">express</a>都可以是你的首选，这里就不再详细展开，请童鞋们参照官方手册或民间攻略安装和配置。

</p>
<p><em>至此，需要依赖的开发环境已经安装妥当，接下去，让我们先Hello World吧！</em>

</p>
<p><strong>配置SPM源</strong>

</p>
<p>创建一个SPM源服务器（请参见<code>SPM</code>的相关文档）。然后进入上述建立的<code>.spm</code>目录，打开config.json，设置里面的sources字段为搭建好的SPM源服务器。

</p>
<h2>开始十分钟之旅</h2>
<p><strong>获取MIX框架并编译</strong>

</p>
<p>新建一个MIX框架的目录。

</p>
<p>请用<code>git clone</code>以及<code>git submodule update --init</code> 命令来获取最新的框架源码（<a href="https://github.com/mixteam/mix">GITHUB</a> ）。


</p>
<p>在MIX源码的根目录下，执行如下命令

</p>
<pre><code>$ spmbatch upload</code></pre>
<p>完成后所有的MIX模块都已经编译并上传自SPM源服务器了。你可以通过类似<code>http://{path_to_spm_sources}/mix/core/base/class/1.0.0/class.js</code>这样的地址，来访问源服务器上的某个模块的js文件。

</p>
<h2>初始化Hello World项目</h2>
<p>新建一个项目目录，名为<code>helloworld</code>，并在当前项目路径下执行如下命令：

</p>
<pre><code>$ projinit -ex helloworld</code></pre>
<p>系统会自动生成基础目录和文件，如下：

</p>
<pre><code>- ./
    - src
        helloworld.js
    seajsConf.js
    README.md
    package.json
    index.html
    .monitor</code></pre>
<p>接下去，需要简单操作，从而达到能运行的目的：

</p>
<ul>
<li>修改seajsConf.js和index.html中的名为<code>path_to_spm_source</code>的位置为SPM源服务器</li>
<li>运行<code>spm upload</code></li>
<li>配置HTTP服务器，指向该项目目录</li>
</ul>
<p>最后打开通过浏览器访问项目所在的URL（例如<a href="http://localhost/helloworld/），就可以展现华丽丽的Hello">http://localhost/helloworld/），就可以展现华丽丽的Hello</a> MIX World!了。

</p>
<h2>读懂Hello World项目</h2>
<p><code>index.html</code>为整个项目的入口。其中的三个script标签，分别引入了seajs，seajsConf，以及用seajs的use方法，获取了helloworld.js中exports的字符串文本，并把它显示出来。

</p>
<p>就是这么简单！

</p>
<p>至此，Hello MIX World！只是加载了一个模块，返回一串文字而已，并没有使用MIX的核心框架。接下来需要一步步的来建立真正的MIX World。

</p>
<h2>继续Hello World项目</h2>
<p>MIX框架，是专门为OPOA设计的。它基于url的hashChange来进行路由选择，然后来管理和通知某个应用。MIX框架中，用于支持路由的模块为<code>router@0.2.0</code>，用于支持应用管理的模块为<code>navigator@0.1.0</code>。因此，我们要把这两个模块的依赖加入到package.json里去。如下：

</p>
<pre><code>&quot;dependencies&quot; : {
    &quot;router&quot; : &quot;mix/core/util/router/0.2.0/router&quot;,
    &quot;navigator&quot; : &quot;mix/core/util/mvc/navigator/0.1.0/navigator&quot;
}</code></pre>
<p>打开并编辑<code>./src/helloworld.js</code>文件，在此文件中来启动整个项目：

</p>
<pre><code>define(function(require, exports, module) {
    var router = require(&#39;router&#39;).singleton,
        navigator = require(&#39;navigator&#39;).singleton
        ;

    navigator.trigger(&#39;install&#39;);
    router.start();

    return &#39;router started&#39;;
});</code></pre>
<p>再次执行<code>spm upload</code>，输入地址<code>http://localhost/helloworld/#hellomix/</code>，看到页面上，显示router started。表示路由功能已经启动成功。但同时也会发现在console中会抛出一个错误，显示<code>http://localhost/mix/test/apps/hellomix/entry.js</code>无法找到。因为，我们访问了hellomix这个应用，而这个应用我们还未建立。接下去就来建立这个mix应用。

</p>
<h2>建立Hello MIX应用</h2>
<p>应用存放的路径默认为项目下的apps目录，于是，我们就在<code>./apps</code>下新建一个<code>hellomix</code>文件夹（请注意大小写）。并执行如下命令：

</p>
<pre><code>$ projinit -ex hellomix</code></pre>
<p>生成的目录文件结构如下

</p>
<pre><code>- ./apps/hellomix
    - assets
        view.less
        view.mu
    - src
        controller.js
        route.js
        view.js
    entry.js
    package.json</code></pre>
<p>正如你看到的，每个应用它可以看作是一个独立的<code>spm模块</code>，需要单独执行<code>spm build</code>或<code>upload</code>命令。

</p>
<p><strong>package.json</strong>

</p>
<p>用于描述该应用，先来为它设置几个主要参数

</p>
<p>更多<code>package.json</code>的相关知识，请参阅<a href="https://github.com/seajs/spm/wiki/Spm-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B">SPM官方文档</a>。

</p>
<p><strong>entry.js</strong>

</p>
<p>即为hellomix应用的入口文件。框架的应用管理器（即navigator）会自动加载这个文件。

</p>
<p><strong>contorller.js，route.js，view.js</strong>

</p>
<p>分别为应用的控制器层，路由配置和视图层。控制器层和视图层之间，视图和视图之间通过消息来传递数据。

</p>
<ul>
<li>控制器用来加载指定的路由和视图。</li>
<li>路由配置，指定了路由选择的语法。</li>
<li>视图层的开发，可以有这些内容:<ul>
<li>匹配路由</li>
<li>监听view之间的消息</li>
<li>给模版绑定DOM事件</li>
<li>为组件绑定初始化数据</li>
<li>更新（局部）模版</li>
</ul>
</li>
</ul>
<p><strong>view.less, view.mu</strong>

</p>
<p>为视图的模版和样式。MIX框架采用<a href="http://lesscss.org">less语法</a>的样式，和<a href="http://handlebarsjs.com/">mustache语法</a>的模版来为视图进行渲染。

</p>
<p>同样，执行<code>spm upload</code>，刷新浏览器，你会发现，这世界多么的美好！

</p>
<h2>进阶Hello MIX应用</h2>
<p>其实，还没完呢。在上面的例子中，我们用到了router来进行路由选择，用到了navigator来管理和通知应用，用视图来渲染模版。但，MIX框架不仅仅只是这些。

</p>
<h3>如何从路由中获取参数</h3>
<p>Helloworld是每个开发者的进阶之路，我们不能满足于显示<code>Hello MIX World!</code>也许我们希望根据不同的数据来显示不同的<code>Hello XXX World！</code>那好，我们假设通过这样的<code>#hellomix/M.J</code>的hash，最终能显示<code>Hello M.J World!</code>。

</p>
<p>好的，那么准备工作是需要先为应用增加一条路由匹配，编辑应用下的<code>./src/route.js</code>：

</p>
<pre><code>define({
    &#39;&#39; : &#39;hellomix&#39;,
    &#39;:what&#39; : &#39;hellowhat&#39;    /*增加的路由选择*/
});</code></pre>
<p>其中增加的&#39;:what&#39;语法，表示选择如同<code>#hellomix/aaa</code>、<code>#hellomix/bbb</code>等这样的hash，并且把<code>aaa</code>或<code>bbb</code>的赋值给what参数。

</p>
<p>然后，需要为该路由编写处理的方法，编辑<code>./src/view.js</code>：

</p>
<pre><code>define(function(require, exports, module) {
    var View = require(&#39;view&#39;),
        HelloView = {}
        ;

    // 一些配置项，包括加载模版和样式的地址
    HelloView.CONFIGS = {
        name : &#39;helloview&#39;,
        viewport : &#39;#screen-wrap&#39;,
        loadTmpl : &#39;apps/hellomix/assets/view.mu&#39;,
        loadStyle : &#39;apps/hellomix/assets/view.less&#39;
    }

    // 消息
    HelloView.EVENTS = {
        &#39;beforeRender&#39; :  &#39;setWhatData&#39;  /*在视图渲染前执行setWhatData方法*/
    }

    // 设置匹配的某路由后，对应执行的方法
    HelloView.ROUTES = {
        &#39;hellomix&#39; : &#39;renderHelloMIX&#39;,
        &#39;hellowhat&#39; : &#39;renderHelloWhat&#39;    /*名为hellowhat的路由会调用renderHelloWhat方法*/
    }

    // 模版的数据
    HelloView.DATA = {
        what : &#39;MIX&#39;
    }


    Object.extend(HelloView, {
        setWhatData : function() {
            var that = this,
                contro = that.getController(),
                what = contro.getParameter(&#39;what&#39;)
                ;

            // 从hash的参数获得值中，并设置模版数据
            that.setData(&#39;what&#39;, what);
        },

        renderHelloMIX : function() {
            // 追加一个awesome文本
            var text = document.createTextNode(&#39;--awesome!&#39;);
            document.body.appendChild(text);
        },

        renderHelloWhat : function(what) {
            // 追加一个That&#39;s it!文本
            var text = document.createTextNode(&#39;--That\&#39;s it!&#39;);
            document.body.appendChild(text);
        }
    });

    // 导出View的一个子类
    module.exports = View.extend(HelloView);
});</code></pre>
<p>其中，我们增加几个关键选项

</p>
<p><strong>beforeRender消息</strong>

</p>
<p>这里指定了，当收到beforeRender消息时，应该执行的方法

</p>
<p><strong>名为hellowhat的路由</strong>

</p>
<p>这里指定了，匹配hellowhat路由时，应该执行的方法

</p>
<p><strong>DATA数据</strong>

</p>
<p>同时，我们为模版提供了一个名为what的数据项，默认为&quot;MIX&quot;。

</p>
<p><strong>setWhatData方法</strong>

</p>
<p>在此方法中，我们在渲染模版前，修改了what的数据值为hash中的第一个参数。

</p>
<p>最后，我们略微修改下模版，使模版支持数据填充：

</p>
<pre><code>&lt;strong&gt;Hello &lt;span&gt;{{{what}}}&lt;/span&gt; World!&lt;/strong&gt;</code></pre>
<p>大功告成，同样<code>spm upload</code>后，访问<code>http://localhost/mix/demos/helloworld/#hellomix/M.J</code>地址，并刷新。你会看到如同M.J那样的神奇一幕！

</p>
<p><strong>如果你对上面的一切觉得繁琐，那么你可以偷懒下，直接浏览MIX框架下<code>demos/helloworld</code>即可</strong>

</p>
<h2>小甜点</h2>
<h3>文件监控</h3>
