<h1>序（持续更新）</h1>
<h2>文件组织</h2>
<p>less文件包含两部分：（从文件组织角度考虑）

</p>
<ul>
<li>函数</li>
<li>class</li>
</ul>
<p>函数分为：

</p>
<ul>
<li>基本。基于组件，组件内部特有的函数。</li>
<li>通用。组件间提取出来，在组件之间可以使用。</li>
</ul>
<p>class分为：

</p>
<ul>
<li>基本。这部分class提供最基本的组件样式完整展示。</li>
<li>扩展。这部分class属于定制，在业务中可能有许多定制的部分，如给Button加上箭头。突破基本样式的以扩展class形式展现。</li>
</ul>
<h1>和之前的区别</h1>
<p>最重要的几个衡量指标：灵活性，可扩展性，可维护性。


</p>
<h2>h5</h2>
<pre><code>1.多用class标签；
2.级联和DOM结构关联度较高；
3.总的域名空间#tbh5v0；
4.实现方式容易理解；
5.业务关联度高:比如说页尾，Less结构：
.footer{
    a{
    }
    .footer-t{
        .user-info{}
        .gotop{}

    }
    .footer-l{
    }
    .copyright{
    }
}

6.和bootStrap比较起来H5的less结构稍显混沌：如下代码：
.c-list-sort{
    &amp;:after{}
    li{
        &amp;.highlight{}
        &amp;.sort-asc, &amp;.sort-desc  {
            label{}
            span{}
            em{
                &amp;:first-child{}
                &amp;:last-child{}
            }
        }
        &amp;.sort-asc{
            em{
                &amp;:first-child{}
                &amp;:last-child{}
            }
        }
        &amp;.sort-desc{
            em{
                &amp;:first-child{}
                &amp;:last-child{}
            }
        }
    }

}

再比如分页：
.c-pnav-con{
    a{}
    ul{
        li{}

    }
    .c-p-sec{
        div{}
        .tri(){
            a{}
            .c-p-p{
                em{}
            }
        }
    }

    .c-p-pre{}
    .c-p-next{}
    .c-p-cur{
        .c-p-arrow{
            span:first-child{}
        }
        .c-p-down{
            span:last-child{}
        }
        .c-p-up{
            span:last-child{}
        }
    }

    .c-p-grey{
        a{}
    }

    .c-p-select{}
}

盘根错节的结构，几乎没有什么维护性可言。</code></pre>
<h2>TaobaoPad</h2>
<pre><code>1.独立控件 独立命名空间，结构清晰，如text控件：
#c-text {    
    //空间内的公用函数
    .circle(@w) {}
    .pack-text(@w: 298px, @h: 33px) {}

    //空间内的基本样式class和样式扩展
    .c-text {}
}

//公共样式.
.c-XXX{}

2.相似功能函数分布在不同的控件的命名空间下，各自维护，耦合低，灵活度高，但当一个人维护代码（集中维护）时需要维护多份相同code。
3.扩展上来说，由于单个控件内单个func，扩展起来互不打扰。</code></pre>
<h2>bootStrap</h2>
<pre><code>1.样式集中在标签的功能部分，比如input只考虑foucs，disable，required等等。所有的这些考虑都是从input的功用出发。
2.兼容性处理，这块做的比较多。除了浏览器兼容以外，还有“遵循‘One class, multiple tags”。
3.比较少的class标签，更多的是元素选择器标签，从功能上来说，比之H5，业务耦合很低    。
4.不可避免的DOM结构。要实现某些表现形式，需要按照约定的DOM结构来，这点和H5比较类似。但是约定强度依然比较低。
5.集中式抽取公共func，设计上麻烦些，而且有可能面对扩展的风险。</code></pre>
<ref name="1.JPG"></ref>

<p>如上图，TaobaoPad的内容集中在控件。bootStrap由于抽出一部分func集中管理。因此控件大小在各个结构中就显得“瘦”和“胖”。

</p>
<p><strong>再一个问题：LESS文件输出问题</strong>

</p>
<p>假设文件结构如下图:

</p>
<ref name="2.JPG"></ref>

<p>基础LESS：

</p>
<pre><code>.base{
    text-align:e(&quot;base&quot;);
}</code></pre>
<p>a1.less:

</p>
<pre><code>@import &quot;base&quot;;

.a1{
    text-align:e(&quot;a1&quot;);
}</code></pre>
<p>a2.less

</p>
<pre><code>@import &quot;base&quot;;

.a2{
    text-align:e(&quot;a2&quot;);
}</code></pre>
<p>a.less

</p>
<pre><code>@import &quot;a1&quot;;
@import &quot;a2&quot;;

.a{
    text-align: e(&quot;a&quot;);
}</code></pre>
<p>b1.less

</p>
<pre><code>@import &quot;base&quot;;

.b1{
    text-align:e(&quot;b1&quot;);
}</code></pre>
<p>b2.less

</p>
<pre><code>@import &quot;base&quot;;

.b2{
    text-align:e(&quot;b2&quot;);
}</code></pre>
<p>b.less

</p>
<pre><code>@import &quot;b1&quot;;
@import &quot;b2&quot;;

.b{
    text-align: e(&quot;b&quot;);
}</code></pre>
<p>c.less

</p>
<pre><code>@import &quot;base&quot;;

.c{
    text-align:e(&quot;c&quot;);
}</code></pre>
<p>output.less

</p>
<pre><code>@import &quot;a&quot;;
@import &quot;b&quot;;
@import &quot;c&quot;;
.output{
    text-align:e(&quot;output&quot;);
}</code></pre>
<p>最终生成的CSS文件如下：

</p>
<pre><code>.base{text-align:base;}
.a1{text-align:a1;}
.base{text-align:base;}
.a2{text-align:a2;}
.a{text-align:a;}
.base{text-align:base;}
.b1{text-align:b1;}
.base{text-align:base;}
.b2{text-align:b2;}
.b{text-align:b;}
.base{text-align:base;}
.c{text-align:c;}
.output{text-align:output;}</code></pre>
<p><strong>即最终输出文件包含5个base.less文件，而不是想要的一个</strong>


</p>
<p>综合比较，由于bootStrap是通用库，其中会使用很多标签选择器：如from中对legend的定义：

</p>
<pre><code>// Groups of fields with labels on top (legends)
legend {
  display: block;
  width: 100%;
  padding: 0;
  margin-bottom: @baseLineHeight;
  font-size: @baseFontSize * 1.5;
  line-height: @baseLineHeight * 2;
  color: @grayDark;
  border: 0;
  border-bottom: 1px solid #e5e5e5;

  // Small
  small {
    font-size: @baseLineHeight * .75;
    color: @grayLight;
  }
}</code></pre>
<blockquote>
<p>从使用自由度而言：标签选择器的使用会降低自由度，而class更灵活一些。除非在已知而且DOM结构不频繁发生变化的DOM中，标签选择器是一个选择。


</p>
</blockquote>
<p>bootStrap中的这种方式降低了一定的自由度。对设计的要求较高。

</p>
<h1>规范化</h1>
<h2>命名</h2>
<p>命名规范，在控件Class命名上基本上和规范靠近。而且命名要具有一定的“辨识度”。

</p>
<p>如Accordion、carousel所代表的意思和控件是什么？？？

</p>
<h3>class 命名</h3>
<h3>函数命名</h3>
<h3>变量命名</h3>
<p>尽量保持语义：如：

</p>
<pre><code>@sansFontFamily:        &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif;
@btnBackground:                     @white;</code></pre>
<h2>组件样式规范（从组件角度考虑）</h2>
<p>这部分主要处理组件的必要属性定义，分为Core、basic、extend几个部分。

</p>
<ul>
<li>Core部分，一个组件能够展现的最基础的部分（这里的说的最基础，可能不是组件的物理属性，而是应用中最常使用的部分）。如Button的边框，圆角。（这些属性在项目使用很频繁）</li>
<li>basic部分，如长、宽，背景色、文字颜色、阴影等等。</li>
<li>extend部分，这部分根据业务的具体需要有一定的“定制”成分。如给Button加个箭头，这里可能就需要修改Button的DOM结构，此类以CLass形式专门提供</li>
</ul>
<h1>处理兼容问题</h1>
<p>此处暂时只支持webkit，故兼容性问题只在不同的webkit的版本和浏览器之间考虑。

</p>
<h1>函数设计问题</h1>
<p>如何设计一个函数，一个组件的函数应改考虑哪些方面？

</p>
<ul>
<li>基本&amp;针对性，一些属性是组件的通用的属性，这一部分可以单独设计，而一些属性是某些组件特有的“属性”，这部分可以通过函数形式Mixin进来。</li>
<li>可用性，可用性要高，在使用时要保证尽可能的方便。</li>
<li>扩展性，面对可能变化的需求，需要留出一定的扩展的空间。特别在结构上，不能没有扩展性。</li>
<li>复用性，保证一些常用函数的比较好的复用性，维护代码简洁度。</li>
</ul>
<h3>less函数的作用</h3>
<ul>
<li><p>用作hack</p>
</li>
<li><p>用作合并（mixin）</p>
</li>
</ul>
<h3>处理扩展性</h3>
<p><strong>Q：</strong>如果在一个less function中遇到一个自认为不需要重写的属性，但是在后续的开发中又需要单独扩展，该如何处理？？
如下代码：


</p>
<pre><code>.btn {
  display: inline-block;
  .ie7-inline-block();
  padding: 4px 12px;
  margin-bottom: 0; // For input.btn
  font-size: @baseFontSize;
  line-height: @baseLineHeight;
  ...</code></pre>
<p><strong>A：</strong>正如你看到的，bootstrap把可能会变化的部分都改成了变量。然后就可以生成不同版本的控件。


</p>
<p><strong>Q：</strong>如果使用者在使用v0.1按钮组件：
    ；字体大小为14px
    ；行高为18px
    在v0.2的版本中，由于需求原因，字体和行高改成如下：
    ；字体大小为12px
    ；行高为14px
    （附：某些属性是有很大的联动特征的，如这里的字体大小和行高）
    但是某个使用者想使用v0.1的字体大小，和v0.2的行高，怎么办？？？

</p>
<p><strong>A：</strong>对不起，版本一旦固定，不提供组件级别的修改，可以在自己的应用针对的修改覆盖。


</p>
<p><strong>Q：</strong>一些扩展可以通过变量实现，也可以通过class实现，两者如何区分？
<strong>A：</strong>变量是相对不变的（在版本和版本之间的变化），而class则是对业务的扩展，一个还是在原来的“坑”，一个是挖了很多“坑”。而两者都表现在版本的更迭中。


</p>
<h3>技巧(tricks)</h3>
<p>1.通配符。

</p>
<pre><code>[class^=&quot;icon-&quot;],
[class*=&quot; icon-&quot;] {
     display: inline-block;</code></pre>
<p>2.Mix in

</p>
<pre><code>input[type=&quot;button&quot;] {
  &amp;.btn-block {
    width: 100%;
  }
}</code></pre>
<p>一个DOM元素在CSS中有多种选择方式：
+ class
+ 标签
+ 选择符（关系、属性、伪类等）
+ ID


</p>
<p>结合使用可以实现定制。


</p>
<h1>变量定义</h1>
<p>bootStrap按以下几个部分对变量进行了划分：

</p>
<p>主要划分标准：

</p>
<pre><code>控件
颜色
尺寸</code></pre>
<ul>
<li>Grays</li>
<li>Accent colors(浓色)</li>
<li>Scaffolding</li>
<li>Links</li>
<li>Typography</li>
<li>Component sizing（Based on 14px font-size and 20px line-height）</li>
<li>Tables</li>
<li>Buttons</li>
<li>Forms</li>
<li>Dropdowns</li>
<li>Z-index master list(COMPONENT VARIABLES)</li>
<li>Sprite icons path</li>
<li>Input placeholder text color</li>
<li>Hr border color</li>
<li>Horizontal forms &amp; lists</li>
<li>Wells</li>
<li>Navbar</li>
<li>Pagination</li>
<li>Hero unit</li>
<li>Form states and alerts</li>
<li>Tooltips and popovers</li>
<li>GRID</li>
</ul>
<h1>组件</h1>
<h2>Form</h2>
<p>1.最基本的布局、字体、排版属性。
2.不可编辑、不可用
3.获得焦点

</p>
<h2>Button</h2>
<p>class

</p>
<p>func


</p>
<p>bootStrap的设计方式是选择符+class。
1.基本标签：

</p>
<pre><code>label,
input,
button,
select,
textarea</code></pre>
<p>input展开：

</p>
<pre><code>input[type=&quot;text&quot;],
input[type=&quot;password&quot;],
input[type=&quot;datetime&quot;],
input[type=&quot;datetime-local&quot;],
input[type=&quot;date&quot;],
input[type=&quot;month&quot;],
input[type=&quot;time&quot;],
input[type=&quot;week&quot;],
input[type=&quot;number&quot;],
input[type=&quot;email&quot;],
input[type=&quot;url&quot;],
input[type=&quot;search&quot;],
input[type=&quot;tel&quot;],
input[type=&quot;color&quot;]
input[type=&quot;radio&quot;],
input[type=&quot;checkbox&quot;]
input[type=&quot;file&quot;],
input[type=&quot;image&quot;],
input[type=&quot;submit&quot;],
input[type=&quot;reset&quot;],
input[type=&quot;button&quot;],
input[type=&quot;checkbox&quot;]</code></pre>
<p>select展开：

</p>
<pre><code>select[multiple],
select[size]</code></pre>
<p>2.class命名：

</p>
<pre><code>uneditable-input
uneditable-textarea</code></pre>
<p>3.DOM约定与灵活性

</p>
<pre><code>&lt;label class=&quot;checkbox&quot;&gt;
  &lt;input type=&quot;checkbox&quot; value=&quot;&quot;&gt;
  Option one is this and that—be sure to include why it&#39;s great
&lt;/label&gt;

&lt;label class=&quot;radio&quot;&gt;
  &lt;input type=&quot;radio&quot; name=&quot;optionsRadios&quot; id=&quot;optionsRadios1&quot; value=&quot;option1&quot; checked&gt;
  Option one is this and that—be sure to include why it&#39;s great
&lt;/label&gt;
&lt;label class=&quot;radio&quot;&gt;
  &lt;input type=&quot;radio&quot; name=&quot;optionsRadios&quot; id=&quot;optionsRadios2&quot; value=&quot;option2&quot;&gt;
  Option two can be something else and selecting it will deselect option one
&lt;/label&gt;</code></pre>
<p><strong>Q:</strong>如这里的class “checkbox”　“radio”为了实现内部DOM展示完整，在原来的input标签外多加了一层label,是否影响灵活性（比如单独使用一个radioButton）？

</p>
<p><strong>A:</strong>这只是一种扩展，最基础的input标签的样式还是提供的，扩展Code（本例的扩展是因为要求好的DOM展现效果，属于DOM级别扩展）如下：

</p>
<pre><code>.radio,
.checkbox {
  min-height: @baseLineHeight; // clear the floating input if there is no label text
  padding-left: 20px;
}
.radio input[type=&quot;radio&quot;],
.checkbox input[type=&quot;checkbox&quot;] {
  float: left;
  margin-left: -20px;
}</code></pre>
<h1>处理冲突</h1>
<p>当前的样式和应用的样式的命名冲突的问题。

</p>
<h2>命名空间</h2>
<p>bootStrap使用到命名空间，这些使用命名空间的func的特点就是有个逻辑上的“所属”关系，与class稍有不同。使用命名空间的好处之一就是：1.友好的数据组织；2.调用的明确性。但是如果在应用中，会不会和应用中的标签冲突？bootStrap在命名上貌似尽可能规避了。。

</p>
<pre><code>#font {
  #family {
    .serif() {
      font-family: @serifFontFamily;
    }

...

#grid {

  .core (@gridColumnWidth, @gridGutterWidth) {

    .spanX (@index) when (@index &gt; 0) {
      (~&quot;.span@{index}&quot;) { .span(@index); }
      .spanX(@index - 1);
    }</code></pre>
<h1>扩展</h1>
<p>分为样式扩展和DOM扩展

</p>
<h2>样式扩展</h2>
<p>如前文所述，样式扩展直接增加定制class

</p>
<h2>DOM扩展</h2>
<p>需要在已有的组件上修改或者增加DOM结构，这些操作尽量不要出现，如果一旦出现，处理方式？


</p>
